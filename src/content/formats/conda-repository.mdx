import { CodeBlock, Tabs, TabsContent, TabsList, TabsTrigger, Note, Tag } from '@/components';


# Conda Repository

Cloudsmith provides public & private repositories for Conda

Conda is a cross-platform, language-agnostic binary package manager. It is the package manager used by Anaconda installations. 

For more information on Conda, please see:

- [Conda Documentation](https://docs.conda.io/)
- [Anaconda](https://www.anaconda.com/)

<Note variant="note" headline="Contextual Documentation">
  The examples in this document are generic. Cloudsmith provides contextual setup instructions within each repository, complete with copy and paste snippets (with your namespace/repo/rsa-key pre-configured).
</Note>

In the following examples:

| Identifier      | Description                                                                               |
| :-------------- | :---------------------------------------------------------------------------------------- |
| OWNER           | Your Cloudsmith account name or organization name (namespace)                             |
| REPOSITORY      | Your Cloudsmith Repository name (also called "slug")                                      |
| TOKEN           | Your Cloudsmith Entitlement Token (see [Entitlements](/software-distribution/entitlement-tokens) for more details) |
| USERNAME        | Your Cloudsmith username                                                                  |
| PASSWORD        | Your Cloudsmith password                                                                  |
| API-KEY         | Your Cloudsmith API Key                                                                   |
| PACKAGE_NAME    | The name of your package                                                                  |
| PACKAGE_VERSION | The version number of your package                                                        |

## Upload a Package

### Creating Conda Packages

To upload via the Cloudsmith API/CLI, you'll need to generate a package first. You can do this with [conda-build](https://docs.conda.io/projects/conda-build/en/latest/index.html):

```
conda build .
```

This generates a `.tar.bz2` file like `your-package-0.1.0.tar.bz2` that you can upload.

### Upload via the Cloudsmith CLI

For full details of how to install and setup the Cloudsmith CLI, see [Command Line Interface](/developer-tools/cli).

The command to upload Conda package via the Cloudsmith CLI is: 

```shell
cloudsmith push conda OWNER/REPOSITORY PACKAGE_NAME-PACKAGE_VERSION.tar.bz2
```

Example:

```shell
cloudsmith push conda my-org/my-repo your-package-0.1.0.tar.bz2
```

### Upload via Cloudsmith web app

Please see [Upload a Package](/artifact-management/package-upload) for details of how to upload via the Cloudsmith web app.

## Download / Install a Package

### Public Repositories

Adding a new channel can be accomplished by using the `conda` CLI:

```shell
conda config --add channels https://conda.cloudsmith.io/OWNER/REPOSITORY/
```

Alternatively, the channel can be added directly to your `.condarc`:

```yaml
channels:
  - https://conda.cloudsmith.io/OWNER/REPOSITORY/
  - defaults
```

Or if you prefer, directly in your `environment.yml` file:

```yaml
name: env-name
channels:
  - https://conda.cloudsmith.io/OWNER/REPOSITORY/
  - defaults
dependencies:
  - python=3.7
  - codecov
```

To confirm the channel exists, you can view the channels configured for Conda by using:

```shell
conda config --show
```

### Private Repositories

<Note variant="note" headline="Private Repositories">
Private Cloudsmith repositories require authentication.  You can choose between two types of authentication, Entitlement Token Authentication or HTTP Basic Authentication. 
The setup method will differ depending on what authentication type you choose to use.
</Note>

<Note variant="warning" headline="Warning">
Entitlement Tokens, User Credentials and API-Keys should be treated as secrets, and you should ensure that you do not commit them in configurations files along with source code, or expose them in any logs.
</Note>
Adding a new channel can be accomplished by using the `conda` CLI:

<Tabs defaultValue="auth1">
  <TabsList>
    <TabsTrigger value="auth1">HTTP Basic Auth (User & Pass)</TabsTrigger>
    <TabsTrigger value="auth2">HTTP Basic Auth (API-Key)</TabsTrigger>
    <TabsTrigger value="auth3">Entitlement Token Auth</TabsTrigger>
  </TabsList>
  <TabsContent value="auth1">
    <CodeBlock lang="shell" header={true}>
      {`conda config --add channels https://USERNAME:PASSWORD@conda.cloudsmith.io/OWNER/REPOSITORY/`}
    </CodeBlock>
  </TabsContent>
  <TabsContent value="auth2">
    <CodeBlock lang="shell" header={true}>
      {`conda config --add channels https://USERNAME:API-KEY@conda.cloudsmith.io/OWNER/REPOSITORY/`}
    </CodeBlock>
  </TabsContent>
  <TabsContent value="auth3">
    <CodeBlock lang="shell" header={true}>
      {`conda config --add channels https://token:TOKEN@conda.cloudsmith.io/OWNER/REPOSITORY/`}
    </CodeBlock>
  </TabsContent>
</Tabs>

Alternatively, the channel can be added directly to your `.condarc`:

<Tabs defaultValue="auth1">
  <TabsList>
    <TabsTrigger value="auth1">HTTP Basic Auth (User & Pass)</TabsTrigger>
    <TabsTrigger value="auth2">HTTP Basic Auth (API-Key)</TabsTrigger>
    <TabsTrigger value="auth3">Entitlement Token Auth</TabsTrigger>
  </TabsList>
  <TabsContent value="auth1">
    <CodeBlock lang="yaml" header={true}>
      {`channels:
  - https://USERNAME:PASSWORD@conda.cloudsmith.io/OWNER/REPOSITORY/
  - defaults`}
    </CodeBlock>
  </TabsContent>
  <TabsContent value="auth2">
    <CodeBlock lang="yaml" header={true}>
      {`channels:
  - https://USERNAME:API-KEY@conda.cloudsmith.io/OWNER/REPOSITORY/
  - defaults`}
    </CodeBlock>
  </TabsContent>
  <TabsContent value="auth3">
    <CodeBlock lang="yaml" header={true}>
      {`channels:
  - https://token:TOKEN@conda.cloudsmith.io/OWNER/REPOSITORY/
  - defaults`}
    </CodeBlock>
  </TabsContent>
</Tabs>

Or if you prefer, directly in your `environment.yml` file:

<Tabs defaultValue="auth1">
  <TabsList>
    <TabsTrigger value="auth1">HTTP Basic Auth (User & Pass)</TabsTrigger>
    <TabsTrigger value="auth2">HTTP Basic Auth (API-Key)</TabsTrigger>
    <TabsTrigger value="auth3">Entitlement Token Auth</TabsTrigger>
  </TabsList>
  <TabsContent value="auth1">
    <CodeBlock lang="yaml" header={true}>
      {`name: env-name
channels:
  - https://USERNAME:PASSWORD@conda.cloudsmith.io/OWNER/REPOSITORY/
  - defaults
dependencies:
  - python=3.7
  - codecov`}
    </CodeBlock>
  </TabsContent>
  <TabsContent value="auth2">
    <CodeBlock lang="yaml" header={true}>
      {`name: env-name
channels:
  - https://USERNAME:API-KEY@conda.cloudsmith.io/OWNER/REPOSITORY/
  - defaults
dependencies:
  - python=3.7
  - codecov`}
    </CodeBlock>
  </TabsContent>
  <TabsContent value="auth3">
    <CodeBlock lang="yaml" header={true}>
      {`name: env-name
channels:
  - https://token:TOKEN@conda.cloudsmith.io/OWNER/REPOSITORY/
  - defaults
dependencies:
  - python=3.7
  - codecov`}
    </CodeBlock>
  </TabsContent>
</Tabs>

### Install a Package

Once configured, you can install packages from your channel using the `conda` CLI:

```shell
conda install your-package=1.2.3
```

Or you can search for packages via blended channels (multiple upstreams configured in your Cloudsmith repository) for any package:

```shell
conda search your-package
```

## Conda repodata patching

In certain scenarios, Conda package metadata may need to be patched. Patching is often required when a package dependency is updated, and backwards compatibility is broken, as in the following example:

- `package-a`, version `3.5.0` depends on `package-b` with a version constraint of `package-b >= 2.0.0`.
- A new major version of `package-b` is released (`3.0.0`). This introduces breaking changes, making it incompatible with all previous versions of `package-a`.

Repodata patching can be used to resolve the above scenario. For example, the dependency constraint can be amended (patched) to the more specific: `package-b >= 2.0.0, <3`. This approach does not alter the original package artifacts, and means no requirement is placed on package maintainers to re-release corrected versions of any existing (broken) packages.

### Applying repodata patching

Patching is accomplished by applying patching instructions to a channel's repodata file (`repodata.json`). This file format is used by Conda channels to provide an index of all packages and their respective metadata within a specific subdirectory (subdir) of the channel. When a request is made for the relevant repodata.json file, the patch instructions are merged with the repodata, and the patched (modified) repodata is returned. An overview of this process is available [here](https://bioconda.github.io/developer/repodata_patching.html).

Cloudsmith provides a dedicated [cloudsmith-conda-repodata-patches](https://github.com/cloudsmith-io/cloudsmith-conda-repodata-patches) repository to facilitate the easy creation of patching instructions. This repository provides relevant scripts and instructions on how to add, generate and submit your patch instructions to Cloudsmith.

Please note that when repodata patching is applied both locally and in the upstream, the local version takes precedence. 

## Upstream Proxying / Caching

<Tag variant="dark-green" theme="legacy">Configurable Proxying</Tag><Tag variant="orange" theme="legacy">Caching</Tag>

---

Please see [Upstream Proxying](/repositories/upstreams) for more details.

Upstreams provide a way to _blend_ multiple Conda repositories into a single repository. Cloudsmith supports proxying and caching from upstream repositories for any available channels. This means you can connect not just the canonical upstreams, but also other popular channels. For example, some of the largest upstream channels include:
- [Anaconda](https://repo.anaconda.com/pkgs/main)
- [Conda-Forge](https://conda.anaconda.org/conda-forge)
- [Bioconda](https://conda.anaconda.org/bioconda)
