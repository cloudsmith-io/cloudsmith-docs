import { CodeBlock, RemoteCodeBlock } from '@/components/CodeBlock';

# Recipe 17: Enforce Consistent Filename Convention 

Validate filename matches a semantic or naming pattern.

<RemoteCodeBlock
  lang="rego"
  src="https://raw.githubusercontent.com/cloudsmith-io/rego-recipes/refs/heads/main/recipe-17/policy.rego"
/>

**Trigger Condition:**  
A user would trigger this policy by uploading a package whose filename does not match the required pattern:

h11-X.Y.Z.tar.gz

Where X, Y, and Z are numeric version segments (e.g., h11-1.2.3.tar.gz is valid).

**When and How It's Triggered**  
Examples that do not trigger the policy (valid):

- h11-1.0.0.tar.gz  
- h11-12.5.9.tar.gz

Examples that will trigger the policy:

- h11.tar.gz → missing version  
- h11-1.2.tar.gz → incomplete version  
- h11-1.2.3.zip → wrong extension  
- h11_v1.2.3.tar.gz → wrong format  
- h11-1.2.3.tar.gz → wrong prefix

Let's test it out by renaming a legitimate package with the correct filename convention to one with an incompatible version (or in this case has no semantic version) naming:

pip download h11==0.14.0 && mv h11-*.whl "h11-test.whl"  
cloudsmith push python acme-corporation/acme-repo-one h11-test.whl -k "$CLOUDSMITH_API_KEY"

Filters only filenames starting with h11-  
Matches filenames with:

- A semantic version (X.Y.Z)  
- A valid extension: .tar.gz or .whl

Triggers match when the file violates either rule  
![][image19]

Looking back in our web UI we can see that the package was correctly matched by our Rego policy and a tag of “inconsistent-filename” was added to our package:

![][image20]

As with most of the examples in this cookbook, we're not telling users that they must strictly adhere to the policies in this cookbook, rather these Rego samples should demonstrate the flexibility of Cloudsmith's OPA policy implementation. If you do have governance controls that you believe can be scoped into semantic versioning on filenames, then this is certainly an approach you could explore.  
![][image21]

