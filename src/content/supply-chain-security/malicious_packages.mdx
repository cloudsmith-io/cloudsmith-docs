import { Note, BlockImage } from '@/components';

import policy_malicious_packages from './images/policy_malicious_packages.png';
import malicious_package from './images/malicious_package.png';

# Malicious Packages

Malicious packages are artifacts published to public registries like NPM, PyPI, or RubyGems, that have been **intentionally crafted by an attacker to cause harm**. When developers unwittingly include these packages in their applications, they open the door to data theft, ransomware, and other damaging attacks for anyone using the affected artifacts. Malicious packages are a subset of malware (it's malicious software) and a delivery vehicle for malware. 

A recent example of a malicious package is the PyPi package `django-log-tracker`. ` django-log-tracker` was a dormant package that was updated in 2024 after nearly two years without new releases in order to propagate information stealer malware. The threat of malicious packages has grown in recent years, even as public registries introduce stronger security controls.

<Note variant="note" headline="Software Vulnerabilities (CVE) vs. Malicious Packages">
A **software vulnerability**, often identified by a Common Vulnerabilities and Exposures (CVE) ID, is an _unintentional_ flaw in the code. It's a bug that, if exploited by an attacker, could lead to a security breach. These vulnerabilities are typically the result of errors in design or implementation.

For example, the **Log4Shell** vulnerability (**CVE-2021-44228**) was a flaw in the popular Log4j logging library for Java that allowed attackers to gain remote code execution over compromised systems. The library itself was not created with malicious intent.
</Note>

## How malicious packages are introduced in dependencies

Malicious actors attempt to breach the software supply chain by disguising harmful packages as legitimate, tricking developers into including them in their projects. Common techniques include:

- **Typosquatting**: A new package is published with a name that is a common misspelling of a popular one. For example, publishing `reqeusts` to trick developers who meant to install the legitimate `requests` library in Python.
- **Dependency Confusion**: This technique targets corporate build systems. An attacker discovers the name of a private, internal package (e.g., `acme-auth`) and publishes a malicious package with the same name to a public registry, often with a higher version number, tricking automated tools into downloading it.
- **Account Takeover**: Attackers compromise the account of a legitimate package maintainer. They then publish a new, malicious version of the trusted package. For instance, if the maintainer of `super-utils` gets their account stolen, an attacker could release version `1.2.4` containing code to steal credit card information.
- **Protestware/Malicious Maintainers**: Sometimes, the threat comes from the package maintainers themselves. As an act of protest or malice, they might add harmful code to their own popular library. For example, the maintainer of `node-ipc` added code that would delete files on systems with specific IP addresses as a form of protest.

## OSV and OpenSSF Malicious Packages

Cloudsmith uses the **OpenSSF Malicious Packages project** - distributed through [OSV.dev](https://osv.dev/) - as a trusted source for detecting malicious packages in open-source software. The OpenSSF Malicious Packages project is a community-driven effort to collect and document confirmed malicious packages found in the wild across multiple package registries.

OSV.dev, initiated by Google, provides a unified, open, and distributed database for vulnerability information, making it easy for developers and automated security tools to consume. By cataloging malicious packages within OSV.dev, the OpenSSF project centralizes intelligence that helps developers and organizations quickly identify threats and strengthen their software supply chains.

## Malicious package detection in Cloudsmith

<Note variant="note" headline="Plans">
Malicious package detection via OSV.dev is available for Ultra and Enterprise customers.
</Note>

The malicious packages dataset is integrated into [Enterprise Policy Management](/supply-chain-security/epm) and [Continuous Security](/supply-chain-security/continuous-security) (both in Early Access). This allows you to define policies that automatically take action when a malicious package is detected.

For example, here we can see an EPM policy that quarantines any package that is considered malicious in the OSV database (and tags it with `MALICIOUS_PACKAGE`):

<BlockImage src={policy_malicious_packages} alt=""></BlockImage>

If you upload a package flagged as malicious, the policy automatically triggers and quarantines it.

<BlockImage src={malicious_package} alt=""></BlockImage>

### Example Rego policy

To flag any artifact considered malicious in Cloudsmith, check whether the`vulnerability.id` field starts with the prefix `MAL-` - all malicious packages are identified with this string. 

Hereâ€™s an example policy:

```rego
package cloudsmith

default match := false

match if count(malicious_packages) > 0

malicious_packages := [vulnerability.id |
	some vulnerability in input.v0.osv
	startswith(vulnerability.id, "MAL-")
]
```

### Supported Formats

Below you can find the package [formats supported](https://github.com/ossf/malicious-packages/tree/main/osv/malicious) by the OSSF Malicious Packages project:

| Registry / Manager | Language / Ecosystem |
| ------------------ | -------------------- |
| `crates-io`        | Rust                 |
| `docker`           | Docker               |
| `go`               | Go                   |
| `maven`            | Java                 |
| `npm`              | JavaScript / Node.js |
| `nuget`            | .NET                 |
| `pypi`             | Python               |
| `rubygems`         | Ruby                 |